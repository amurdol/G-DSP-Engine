#!/usr/bin/env python3
# ============================================================================
# G-DSP Engine — Constellation Frame Visualizer
# ============================================================================
# Author : G-DSP Team
# Project: TFG — 16-QAM Baseband Processor on Gowin GW1NR-9
# License: MIT
# ============================================================================
#
# Reads CSV output from tb_constellation_renderer and visualizes the frame.
# Shows original 640x480 image and scaled 1920x1080 version side by side.
#
# Usage:
#   python scripts/visualize_constellation.py [path_to_csv]
#
# Default CSV path: constellation_frame.csv
# ============================================================================

import sys
import os
import numpy as np
import matplotlib.pyplot as plt
from PIL import Image
from pathlib import Path

# ============================================================================
# Configuration
# ============================================================================
# VGA resolution
VGA_WIDTH = 640
VGA_HEIGHT = 480

# Target resolution for scaling (1080p)
HD_WIDTH = 1920
HD_HEIGHT = 1080

# Output directory for saved images
OUTPUT_DIR = Path("sim/output")


# ============================================================================
# CSV Parser
# ============================================================================
def load_frame_from_csv(csv_path: str) -> np.ndarray:
    """
    Load frame data from CSV file generated by testbench.

    CSV format: x,y,r,g,b (one line per pixel)

    Args:
        csv_path: Path to the CSV file

    Returns:
        numpy array of shape (480, 640, 3) with RGB values [0-255]
    """
    print(f"Loading frame from: {csv_path}")

    # Initialize frame buffer (black)
    frame = np.zeros((VGA_HEIGHT, VGA_WIDTH, 3), dtype=np.uint8)

    # Read CSV
    pixel_count = 0

    with open(csv_path, "r") as f:
        # Skip header
        header = f.readline().strip()
        if header != "x,y,r,g,b":
            print(f"Warning: Unexpected header: {header}")

        # Parse pixels
        for line_num, line in enumerate(f, start=2):
            line = line.strip()
            if not line:
                continue

            try:
                parts = line.split(",")
                x = int(parts[0])
                y = int(parts[1])
                r = int(parts[2])
                g = int(parts[3])
                b = int(parts[4])

                # Validate coordinates
                if 0 <= x < VGA_WIDTH and 0 <= y < VGA_HEIGHT:
                    frame[y, x] = [r, g, b]
                    pixel_count += 1
                else:
                    print(f"Warning: Invalid coordinates ({x}, {y}) at line {line_num}")

            except (ValueError, IndexError) as e:
                print(f"Warning: Parse error at line {line_num}: {e}")
                continue

    print(f"Loaded {pixel_count:,} pixels ({pixel_count * 100 / (VGA_WIDTH * VGA_HEIGHT):.1f}%)")

    return frame


# ============================================================================
# Image Scaling
# ============================================================================
def scale_to_1080p(frame: np.ndarray, method: str = "nearest") -> np.ndarray:
    """
    Scale 640x480 frame to 1920x1080.

    The 4:3 aspect ratio (640x480) needs to be displayed on 16:9 (1920x1080).
    This simulates how a real monitor would stretch the image.

    Scaling factors:
        Horizontal: 1920 / 640 = 3.0×
        Vertical:   1080 / 480 = 2.25×

    Args:
        frame: Input frame (480, 640, 3)
        method: Interpolation method ('nearest', 'bilinear', 'bicubic', 'lanczos')

    Returns:
        Scaled frame (1080, 1920, 3)
    """
    print(f"Scaling to 1080p using {method} interpolation...")

    # Convert to PIL Image
    img = Image.fromarray(frame)

    # Map method names to PIL constants
    resample_methods = {
        "nearest": Image.Resampling.NEAREST,
        "bilinear": Image.Resampling.BILINEAR,
        "bicubic": Image.Resampling.BICUBIC,
        "lanczos": Image.Resampling.LANCZOS,
    }

    resample = resample_methods.get(method.lower(), Image.Resampling.NEAREST)

    # Resize (stretch to 16:9)
    img_scaled = img.resize((HD_WIDTH, HD_HEIGHT), resample=resample)

    return np.array(img_scaled)


# ============================================================================
# Visualization
# ============================================================================
def visualize_frames(frame_vga: np.ndarray, frame_hd: np.ndarray, output_dir: Path = OUTPUT_DIR):
    """
    Display and save both frames side by side.

    Args:
        frame_vga: Original 640x480 frame
        frame_hd: Scaled 1920x1080 frame
        output_dir: Directory to save output images
    """
    # Create output directory
    output_dir.mkdir(parents=True, exist_ok=True)

    # Create figure with two subplots
    fig, axes = plt.subplots(1, 2, figsize=(16, 6))
    fig.suptitle(
        "G-DSP Engine — 16-QAM Constellation Visualization", fontsize=14, fontweight="bold"
    )

    # === Original VGA Frame ===
    ax1 = axes[0]
    ax1.imshow(frame_vga)
    ax1.set_title(f"Original VGA Frame\n({VGA_WIDTH}×{VGA_HEIGHT} pixels, 4:3)")
    ax1.set_xlabel("X (pixels)")
    ax1.set_ylabel("Y (pixels)")
    ax1.set_aspect("equal")

    # Add grid lines at constellation boundaries (approximate)
    center_x, center_y = VGA_WIDTH // 2, VGA_HEIGHT // 2
    ax1.axhline(y=center_y, color="white", linewidth=0.5, alpha=0.3)
    ax1.axvline(x=center_x, color="white", linewidth=0.5, alpha=0.3)

    # === Scaled 1080p Frame ===
    ax2 = axes[1]
    ax2.imshow(frame_hd)
    ax2.set_title(f"Scaled to 1080p\n({HD_WIDTH}×{HD_HEIGHT} pixels, 16:9)")
    ax2.set_xlabel("X (pixels)")
    ax2.set_ylabel("Y (pixels)")
    ax2.set_aspect("equal")

    # Add center lines for scaled version
    center_x_hd, center_y_hd = HD_WIDTH // 2, HD_HEIGHT // 2
    ax2.axhline(y=center_y_hd, color="white", linewidth=0.5, alpha=0.3)
    ax2.axvline(x=center_x_hd, color="white", linewidth=0.5, alpha=0.3)

    plt.tight_layout()

    # Save combined figure
    combined_path = output_dir / "constellation_comparison.png"
    plt.savefig(combined_path, dpi=150, bbox_inches="tight")
    print(f"Saved combined view: {combined_path}")

    # Save individual images
    vga_path = output_dir / "constellation_640x480.png"
    hd_path = output_dir / "constellation_1920x1080.png"

    Image.fromarray(frame_vga).save(vga_path)
    print(f"Saved VGA frame: {vga_path}")

    Image.fromarray(frame_hd).save(hd_path)
    print(f"Saved HD frame: {hd_path}")

    # Show interactive plot
    plt.show()


def analyze_frame(frame: np.ndarray):
    """
    Print statistics about the captured frame.

    Args:
        frame: RGB frame array
    """
    print("\n" + "=" * 60)
    print("  Frame Analysis")
    print("=" * 60)

    # Count non-black pixels
    non_black = np.sum(np.any(frame > 0, axis=2))
    total = frame.shape[0] * frame.shape[1]

    print(f"  Total pixels: {total:,}")
    print(f"  Non-black pixels: {non_black:,} ({non_black*100/total:.2f}%)")

    # Color statistics
    r = frame[:, :, 0]
    g = frame[:, :, 1]
    b = frame[:, :, 2]

    print(f"\n  RGB Statistics:")
    print(f"    Red:   min={r.min():3d}, max={r.max():3d}, mean={r.mean():.1f}")
    print(f"    Green: min={g.min():3d}, max={g.max():3d}, mean={g.mean():.1f}")
    print(f"    Blue:  min={b.min():3d}, max={b.max():3d}, mean={b.mean():.1f}")

    # Detect unique colors (excluding black)
    unique_colors = set()
    for y in range(frame.shape[0]):
        for x in range(frame.shape[1]):
            if np.any(frame[y, x] > 0):
                unique_colors.add(tuple(frame[y, x]))

    print(f"\n  Unique non-black colors: {len(unique_colors)}")

    # List colors with their likely meanings
    color_meanings = {
        (0, 255, 255): "Cyan (Q1: +I, +Q)",
        (0, 255, 0): "Green (Q2: -I, +Q)",
        (255, 255, 0): "Yellow (Q3: -I, -Q)",
        (255, 0, 255): "Magenta (Q4: +I, -Q)",
        (255, 255, 255): "White (Test pattern / Reference)",
        (160, 160, 160): "Light Gray (Main axes)",
        (112, 112, 112): "Medium Gray (Tick marks)",
        (48, 48, 128): "Dark Blue (Decision boundaries)",
        (80, 80, 80): "Dark Gray (Border)",
    }

    print("\n  Detected colors:")
    for color in sorted(unique_colors, key=lambda c: sum(c), reverse=True):
        meaning = color_meanings.get(color, "Unknown")
        count = np.sum(np.all(frame == color, axis=2))
        print(f"    RGB{color}: {count:,} pixels - {meaning}")

    print("=" * 60)


# ============================================================================
# Main Entry Point
# ============================================================================
def main():
    """Main function."""
    print("=" * 60)
    print("  G-DSP Engine — Constellation Frame Visualizer")
    print("=" * 60)

    # Determine CSV path
    if len(sys.argv) > 1:
        csv_path = sys.argv[1]
    else:
        # Default paths to check
        possible_paths = [
            "constellation_frame.csv",
            "sim/tb/constellation_frame.csv",
            "sim/output/constellation_frame.csv",
        ]

        csv_path = None
        for path in possible_paths:
            if os.path.exists(path):
                csv_path = path
                break

        if csv_path is None:
            print("ERROR: Could not find constellation_frame.csv")
            print("Please provide the path as an argument:")
            print("  python visualize_constellation.py <path_to_csv>")
            sys.exit(1)

    # Verify file exists
    if not os.path.exists(csv_path):
        print(f"ERROR: File not found: {csv_path}")
        sys.exit(1)

    # Load frame from CSV
    frame_vga = load_frame_from_csv(csv_path)

    # Analyze frame
    analyze_frame(frame_vga)

    # Scale to 1080p (simulating 16:9 monitor stretch)
    frame_hd = scale_to_1080p(frame_vga, method="nearest")

    # Visualize and save
    visualize_frames(frame_vga, frame_hd)

    print("\nVisualization complete!")


if __name__ == "__main__":
    main()
